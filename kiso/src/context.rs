use std::{
    cell::RefCell,
    future::Future,
    marker::PhantomPinned,
    pin::Pin,
    thread::LocalKey,
    time::{Duration, Instant},
};

/// Deadline for this specific request.
///
/// Kiso uses this context value for setting timeouts and deadlines for RPCs and other
/// requests during request processing. If a more thight deadline is needed for parts
/// of the flow, use the context functions to run them with a different deadline. Note
/// that this wont check if the deadline is really shorter than the current one.
#[derive(Debug, Clone, Copy)]
pub struct Deadline(pub(crate) Instant);

crate::impl_context_for_type!(Deadline);

impl Deadline {
    /// Instant when the deadline will be reached.
    pub const fn instant(self) -> Instant {
        self.0
    }

    /// Timeout to the deadline instant.
    pub fn timeout(self) -> Duration {
        self.0.duration_since(Instant::now())
    }

    /// Create a deadline that expires after the given duration.
    pub fn after(dur: Duration) -> Self {
        Self(Instant::now() + dur)
    }
}

/// Get the current value from the context stack.
///
/// Use this only if you need the value for longer than a simple transformation, [`with`]
/// should be preferred whenever possible.
///
/// All Kiso's context types have a static `current` getter, thus using this function with
/// them is not necessary.
///
/// # Panics
///
/// Panics if no value for the given type is set, or if the cloning of the value panics.
pub fn current<T: Context + Clone>() -> T {
    with(|val: &T| val.clone())
}

/// Get the current value from the context stack.
///
/// Use this only if you need the value for longer than a simple transformation, [`try_with`]
/// should be preferred whenever possible.
///
/// All Kiso's context types have a static `current` getter, thus using this function with
/// them is not necessary.
///
/// # Panics
///
/// Panics if no value for the given type is set, or if the cloning of the value panics.
pub fn try_current<T: Context + Clone>() -> Option<T> {
    try_with(|val: &T| val.clone())
}

/// Executes a function with a reference to the current value in the context stack.
///
/// # Panics
///
/// Panics if no value for the given type is set.
pub fn with<T: Context, O>(f: impl FnOnce(&T) -> O) -> O {
    let Some(val) = try_with(f) else {
        panic!("no context value for type {}", std::any::type_name::<T>());
    };

    val
}

/// Executes a function with a reference to the current value in the context stack.
pub fn try_with<T: Context, O>(f: impl FnOnce(&T) -> O) -> Option<O> {
    T::cell().with_borrow(|s| s.as_ref().map(f))
}

/// Push a value into the context stack inside a function execution.
#[allow(clippy::needless_pass_by_value)]
pub fn scope_sync<T: Context, O>(value: T, func: impl FnOnce() -> O) -> O {
    let _guard = StackGuard::new(value);
    func()
}

/// Push a value into the context stack inside a future execution.
///
/// Note that this function only work with created futures. Sometimes, the futures's
/// creation itself also needs the context value, like in tower's services. In these
/// cases, you need to use both [`scope_sync`] and [`scope`].
pub async fn scope<T: Context, O>(value: T, fut: impl Future<Output = O>) -> O {
    AsyncStackGuard::new(value, fut).await
}

// # Implementation notes
//
// Each context stack can be thought as a stack-based linked list, where each node is a
// combination of the scope value, kept pinned inside the scope functions/futures.
//
// The Context trait allows us to create a thread-local for each context type. The type
// stored in the local is a Cell to a *const (). Using a () ptr instead of a ptr to the
// type itself allow us to have non-'static context types. Having a thread-local per type
// allow us to bypass thread-local checks after the first access, specially important for
// the async guard.
//
// StackGuard's responsability is to ensure the previous stack value is (almost) always
// reset at the end of its scope. Note that, due to Rust not guaranteeing that destructors
// will be run, the value may not be reset, but this only occurs in extreme circuntances.
//
// SAFETY: The code assumes that the destructor for StackGuard being called. As the type
// is module private and only created in controlled functions, namely `scope` and
// `AsyncStackGuard::poll`, the only case where the destructor wouldn't be called is when
// panics abort the program (either `panic = "abort"` or double panicking), but in these
// cases, the thread would be destroyed, together with the thread-local, thus not causing
// memory errors.

/// A type that can be recovered from the local context.
///
/// The only sensible safe implementation can be generated by [`impl_context_for_type`].
///
/// # Safety
///
/// Any implementation of this trait MUST ensure that the [`Cell`] returned by [`Context::cell`]
/// is ONLY used for the context machinery, and is not shared between different types.
///
/// Not upholding this contract WILL cause memory corruption.
pub unsafe trait Context: Sized + 'static {
    fn cell() -> &'static LocalKey<RefCell<Option<Self>>>;
}

#[macro_export]
macro_rules! impl_context_for_type {
    ($ty: ty) => {
        $crate::impl_context_for_type!(noextension $ty);

        impl $ty {
            /// Get the current value from the context stack.
            ///
            /// # Panics
            ///
            /// Panics if no value is set in the context.
            #[inline(always)]
            pub fn current() -> Self {
                $crate::context::current::<Self>()
            }

            /// Get the current value from the context stack.
            #[inline(always)]
            pub fn try_current() -> Option<Self> {
                $crate::context::try_current::<Self>()
            }

            /// Run the given future with this value in context.
            #[inline(always)]
            pub async fn in_scope<O>(self, fut: impl ::std::future::Future<Output = O>) -> O {
                $crate::context::scope(self, fut).await
            }

            /// Run the given function with this value in context.
            #[inline(always)]
            pub fn in_scope_sync<O>(self, f: impl ::std::ops::FnOnce() -> O) -> O {
                $crate::context::scope_sync(self, f)
            }
        }
    };

    (noextension $ty: ty) => {
        unsafe impl $crate::context::Context for $ty {
            fn cell() -> &'static ::std::thread::LocalKey<::std::cell::RefCell<Option<Self>>> {
                thread_local! {
                    static STACK: ::std::cell::RefCell<Option<$ty>> = const { ::std::cell::RefCell::new(None) };
                }

                &STACK
            }
        }
    };
}

struct StackGuard<T> {
    cell: *mut Option<T>,
    prev_item: Option<T>,
    _pinned: PhantomPinned,
}

impl<T: Context> StackGuard<T> {
    fn new(value: T) -> Self {
        let (prev_item, cell) = T::cell().with_borrow_mut(|s| {
            let prev = s.replace(value);
            (prev, std::ptr::from_mut(s))
        });

        StackGuard {
            cell,
            prev_item,
            _pinned: PhantomPinned,
        }
    }
}

impl<T> Drop for StackGuard<T> {
    fn drop(&mut self) {
        // SAFETY: self.cell is valid as Context requires a thread-local static to the cell.
        unsafe { std::mem::swap(self.cell.as_mut().unwrap(), &mut self.prev_item) }
    }
}

struct AsyncStackGuard<F, U> {
    fut: F,
    slot: Option<U>,
}

impl<F, U: Context> AsyncStackGuard<F, U> {
    fn new(value: U, fut: F) -> Self {
        Self {
            slot: Some(value),
            fut,
        }
    }
}

impl<F, U> Future for AsyncStackGuard<F, U>
where
    F: Future,
    U: Context,
{
    type Output = F::Output;

    fn poll(
        self: Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        struct Guard<'a, T> {
            cell: *mut Option<T>,
            prev_item: &'a mut Option<T>,
            _pinned: PhantomPinned,
        }

        impl<T> Drop for Guard<'_, T> {
            fn drop(&mut self) {
                // SAFETY: self.cell is valid as Context requires a thread-local static to the cell.
                unsafe { std::mem::swap(self.cell.as_mut().unwrap_unchecked(), self.prev_item) }
            }
        }

        unsafe {
            let this = self.get_unchecked_mut();

            let cell = U::cell().with_borrow_mut(|s| {
                std::mem::swap(s, &mut this.slot);
                std::ptr::from_mut(s)
            });

            let _guard = Guard {
                prev_item: &mut this.slot,
                cell,
                _pinned: PhantomPinned,
            };

            Pin::new_unchecked(&mut this.fut).poll(cx)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    impl_context_for_type!(noextension &'static str);
    impl_context_for_type!(noextension Vec<u8>);

    #[test]
    fn test_context_stack() {
        scope_sync("bla", || {
            assert_eq!(current::<&'static str>(), "bla");

            scope_sync("foo", || {
                assert_eq!(current::<&'static str>(), "foo");
            });

            scope_sync(vec![1, 2, 3u8], || {
                assert_eq!(current::<Vec<u8>>(), vec![1, 2, 3]);
            });

            assert_eq!(current::<&'static str>(), "bla");
        });
    }

    #[test]
    #[should_panic(expected = "no context value for type &str")]
    fn test_panic_with_no_value() {
        let _ = current::<&'static str>();
    }

    #[test]
    #[should_panic(expected = "no context value for type &str")]
    fn test_panic_no_value_after_scope() {
        scope_sync("foo", || {});
        let _ = current::<&'static str>();
    }
}
